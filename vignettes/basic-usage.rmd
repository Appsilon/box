---
title: "Basic Usage"
author: Konrad Rudolph
date: "`r Sys.Date()`"
output:
    rmarkdown::html_document:
        theme: "cerulean"
        toc: true
        toc_float:
            collapsed: false
        number_sections: true
        highlight: "tango"
    md_document:
        variant: markdown_github
vignette: >
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteIndexEntry{Basic usage}
    %\VignetteEncoding{UTF-8}
---
```{r include=FALSE}
devtools::load_all()
# The module does not export any symbols. We use `[...]` solely to prevent the
# declaration to create a module alias in the calling environment, so this
# implementation detail isn’t shown in subsequent `ls()` calls.
mod::use(./`source-file`[...])
```

## Using modules

For the purpose of this tutorial, we are going to use the example module
`bio/seq`. The module implements some very basic mechanisms for dealing with DNA
sequences (= character strings consisting of the letters `A`, `C`, `G` and `T`).

First, we load the module:

```{r}
mod::use(./bio/seq)
```

The function `mod::use` accepts a list of *unquoted*, *qualified* module names.
Each of these module names will load a single module and make it available to
the caller in some form. In the code above, we’ve loaded a single module,
`seq/seq`. `bio` serves as a *parent module* that may group several submodules.
Since the module name inside `mod::use` starts with `./`, the module location is
resolved *locally*, i.e. relative to the path of the currently running code.

In the above, `seq` is the module’s *proper name*. `bio/seq` is its *fully
qualified name*. And `./bio/seq` is its *`use` declaration*.

To see the effect of this `use` declaration, let’s inspect our workspace:

```{r}
ls()
seq
```

We have used the module’s fully qualified name to load it. But, as shown by
`ls`, loading the module this way only introduces a single new name into the
current scope, the module itself, identified by its proper (non-qualified) name.

To see which names a module exports, we use `ls` again, this time on the module
itself:

```{r}
ls(seq)
```

It appears that `seq` exports `r length(ls(seq))` different names. To access
exported names, we use the `$` operator:
<code>`r paste0('seq$', lsf.str(seq)[[1L]])`</code> allows us to use the first
function in the list of exported names. We can also display the interactive help
for individual names, e.g.:

```{r eval=FALSE}
? seq$revcomp
```

Now let’s actually *use* the module. The `seq` function inside the `dna/seq`
module constructs a set of (optionally named) biological sequences:

```{r}
s = seq$seq(
    gene1 = 'GATTACAGATCAGCTCAGCACCTAGCACTATCAGCAAC',
    gene2 = 'CATAGCAACTGACATCACAGCG'
)

seq$is_valid(s)

s
```

Note how we automatically get pretty-printed
[FASTA](http://en.wikipedia.org/wiki/FASTA_format) output because the `print`
method (which gets called implicitly here) is specialised for the `'bio/seq'` S3
class in the `bio/seq` module (prefixing S3 classes inside modules with the full
module name is a convention to avoid name clashes of S3 classes):

```{r}
getS3method('print', 'bio/seq')
```

The source code for `print.bio/seq` contains an interesting `use` declaration.
It show-cases an alternative way of invoking `mod::use`, which we’ll explore
now.

## Attaching modules

Let’s have a look at alternative ways of using modules.

To start, let’s unload the `bio/seq` module …

```{r}
mod::unload(seq)
```

… and load it again, via a different route:

```{r}
mod::set_options(path = getwd())
mod::use(bio/seq[revcomp, is_valid])
```

After unloading the already loaded module, the `mod::set_options` function call
sets the module search path: this is where `mod::use` searches for modules. If
more than one path is given, `mod::use` searches them all until a module of
matching name is found. This works analogously to how `.libPaths()` operates on
R packages.

The `mod::use` directive can now use `bio/seq` instead of `./bio/seq` as the
module name: rather than a relative name we specify a *global* name. In this
example we set the search path to the current working directory but in normal
usage it would be a global library location, e.g. (following the [XDG base
directory specification][XDG]) `~/.local/R/modules`.

[XDG]: https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html

Note that non-local module names *must* be fully qualified, nested modules:
`mod::use(foo/bar)` works, `mod::use(bar)` does not (instead, it is assumed that
`bar` refers to a *package*).

In the declaration above we use `[revcomp]` to specify that the `revcomp` name
from the `bio/seq` module should be attached in the calling environment. The
`[…]` part is an *attach specification*. A comma-separated list of names inside
the parentheses specifies which names to attach. The special symbol `...`
specifies that *all exported names* should be attached. This has an effect
similar to conventional package loading via `library` (or `attach`ing an
environment): all the attached names are now available for direct use without
necessitating the `seq$` qualifier:

```{r}
is_valid(s)
revcomp(s)
```

However, unlike the `attach` function, module attachment happens *in local
scope* only.

Since the above code was executed in the global environment, there’s no
distinction between local and global scope:

```{r}
search()
```

Note the second item, which reads “<code>`r search()[2]`</code>”. But let’s now
undo that, to attach (and use) the module locally instead:

```{r}
detach()

seq_table = function (s) {
    mod::use(./bio/seq[...])
    table(s)
}

seq_table('GATTACA')
```

Unlike above, we are now attaching *all* exported names instead of specifying
individual names. The subsequent line of code uses the `seq$table` function
rather than `base::table` (which would have a different output). And note that
the `seq` module’s `table` function is *not* attached outside the local scope:

```{r}
search()
table('GATTACA')
```

This is very powerful, as it isolates separate scopes more effectively than the
`attach` function. What is more, modules which are used and attached inside
another module *remain* inside that module and are not visible outside the
module by default.

Nevertheless, the normal, recommended usage of a module is without an attach
specification, as this makes it clearer which names are being referring to.

## Writing modules

The module `bio/seq`, which we have used in the previous section, is implemented
in the file [`bio/seq.r`](bio/seq.r). The file `seq.r` is, by and large, a
normal R source file, which happens to live in a directory named `bio`.

In fact, there are only two things worth mentioning:

1. Documentation. Each function in the module file is documented using the
   [roxygen2](http://cran.r-project.org/web/packages/roxygen2/index.html)
   syntax. It works the same as for packages. The *modules* package parses the
   documentation and makes it available via `module_help` and `?`.

2. The module exports [S3 functions](http://adv-r.had.co.nz/S3.html). The
   *modules* package takes care to register such functions automatically but
   this only works for *user generics* that are defined inside the same module.
   When overriding “known generics” (such as `print`), we need to register
   these manually via `register_S3_method` (this is necessary since these
   functions are inherently ambiguous and there is no automatic way of finding
   them).

## Nesting modules

Modules can also form nested hierarchies. In fact, here is the implementation of
`bio` (in [`bio/__init__.r`](bio/__init__.r): since `bio` is a directory rather
than a file, the module implementation resides in the nested file `__init__.r`):

```{r file='bio/__init__.r'}
```

The submodule is specified as `./seq` rather than `seq`: the explicitly provided
relative path prevents lookup in the import search path (that we set via
`mod::set_options(path = …)`); instead, only the current directory is
considered.

We can now use the `bio` module:

```{r}
mod::set_options(path = NULL) # Reset search path
mod::use(./bio)
ls(bio)
ls(bio$seq)
bio$seq$revcomp('CAT')
```

We could also have implemented `bio` as follows:

```{r eval=FALSE}
#' @export
mod::use(./seq[...])
```

This would have made all of `seq`’s definitions immediately available in
`bio`. This is sometimes useful, but should be employed with care.

## Obsolete information

Module files can contain arbitrary code. It is executed when loaded for the
first time: subsequent `mod::use`s in the same session, regardless of whether
they occur in a different scope, will refer to the loaded, cached module, and
will *not* reload a module.

We can illustrate this by loading a module which has side-effects, `'info'`.

```{r file='info.r'}
```

Let’s load it:

```{r}
mod::use(./info)
```

We have imported the module, and get the diagnostic messages. Let’s re-import
the module:

```{r}
mod::use(./info)
```

… no messages are displayed. However, we can explicitly *reload* a module. This
clears the cache, and loads the module again:

```{r}
# mod::reload(info)
```

And this displays the messages again. The `reload` function is a shortcut for
`unload` followed by `import` (using the exact same arguments as used on the
original `import` call).

The `info` module also show-cases two important helper functions:

1. `module_name` contains the name of the module with which it was loaded. This
   is especially handy because outside of a module `module_name` is `NULL`. We
   can harness this in a similar way to Python’s `__name__` mechanism.

2. `module_file` works equivalently to `system.file`: it returns the full path
   to any file within a module. This is helpful when distributing data files
   with modules, which are loaded from within the module. When invoked without
   arguments, `module_file` returns the full path to the directory containing
   the module source file.
