---
title: "Basic Usage"
author: Konrad Rudolph
date: "`r Sys.Date()`"
output:
    rmarkdown::html_document:
        theme: "cerulean"
        toc: true
        toc_float:
            collapsed: false
        number_sections: true
        highlight: "tango"
    md_document:
        variant: markdown_github
vignette: >
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteIndexEntry{Basic usage}
    %\VignetteEncoding{UTF-8}
---
```{r include=FALSE}
devtools::load_all()
mod::use(./`source-file`)
```

# Working with modules

## The `seq` module

For the purpose of this tutorial, we are going to use the example module
`bio/seq`. The module implements some very basic mechanisms for dealing with DNA
sequences (= character strings consisting of the letters `A`, `C`, `G` and `T`).

First, we load the module:

```{r}
mod::use(./bio/seq)
ls()
seq
```

`bio` serves as a parent module that may group several submodules. Since the
module name inside `mod::use` starts with `./`, the module location is resolved
*locally*, i.e. relative to the path of the currently running code. Furthermore,
we use a module’s *fully qualified name* to load it. But, as shown by `ls`,
loading the module this way only introduces a single new name into the current
scope, the module itself, identified by its proper (non-qualified) name.

To see which names a module exports, we use `ls` again, this time on the module
itself:

```{r}
ls(seq)
```

And to access exported names, we use the `$` operator: `seq$revcomp` allows us
to use the first function in the list of exported names. And we can display
interactive help for individual names, e.g.:

```{r eval=FALSE}
? seq$revcomp
```

Now let’s actually *use* the module. The `seq` function inside the `dna/seq`
module constructs a set of (optionally named) biological sequences:

```{r}
s = seq$seq(c(
    foo = 'GATTACAGATCAGCTCAGCACCTAGCACTATCAGCAAC',
    bar = 'CATAGCAACTGACATCACAGCG'
))

s

seq$is_valid_seq(s)
```

Note how we automatically get pretty-printed
[FASTA](http://en.wikipedia.org/wiki/FASTA_format) output because the `print`
method (which gets called implicitly here) is specialised for the `'bio/seq'`
class in the `bio/seq` module (prefixing S3 classes inside modules with the full
module name is a convention to avoid name clashes of S3 classes):

```{r}
getS3method('print', 'bio/seq')
```

## Attaching modules

So much for the most common usage pattern. In order to understand more about the
module mechanism, let’s look at an alternative usage.

To start, let’s unload the `bio/seq` module and load it again, via a different
route.

```{r}
mod::unload(seq)
```

```{r}
mod::set_options(path = getwd())
mod::use(bio/seq[...])
```

After unloading the already loaded module, the `mod::set_options` function call
sets the module search path: this is where `mod::use` searches for modules. If
more than one path is given, `mod::use` searches them all until a module of
matching name is found.

The `mod::use` directive can now use `bio/seq` instead of `./bio/seq` as the
module name: Instead of a relative module we specify a *global* module. Instead
of the current working directory this would normally be a global library
location, e.g. (following the [XDG base directory specification][XDG])
`~/.local/R/modules`.

[XDG]: https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html

Note that non-local module names must be fully qualified, nested modules:
`mod::use(foo/bar)` works, `mod::use(bar)` does not (instead, mod assumes that
`bar` is a *package* name).

In the command above we also specify that all exported names in the module
should be attached, via `[...]`. The `[…]` part is an *attach specification*. A
comma-separated list of names inside the parentheses specifies which names to
attach. The special symbol `...` specifies that all exported names should be
attached. This has an effect similar to conventional package loading via
`library` (or `attach`ing an environment): all the module’s names are now
available for direct use without necessitating the `seq$` qualifier.

However, unlike the `attach` function, module attachment happens *in local
scope* only. Since the above code was executed in global scope, there’s no
distinction between local and global scope:

```{r}
search()
```

Note the second item, which reads “`r search()[2]`”. But let’s now undo that,
and attach (and use) the module locally instead (normally this would be inside a
function; but `local` serves the same purpose of creating a new scope):

```{r}
detach()

local({
    mod::use(./bio/seq[table])
    table('GATTACA')
})
```

Unlike above, we are only attaching a single name (`tables`) instead of
everything. The subsequent line of code uses `seq`’s `table` function rather
than `base::table` (which would have a different output). Furthermore, note that
*outside* the local scope, the `seq` module’s `table` is not attached:

```{r}
search()
table('GATTACA')
```

This is very powerful, as it isolates separate scopes more effectively than
the `attach` function. What is more, modules which are imported and attached
inside another module *remain* inside that module and are not visible outside
the module by default.

Nevertheless, the normal, recommended usage of a module is without an attach
specification, as this makes it clearer which names are being referring to.

# Implementing modules

The module `bio/seq`, which we have used in the previous section, is implemented
in the file [`bio/seq.r`](bio/seq.r). The file `seq.r` is, by and large, a
normal R source file, which happens to live in a directory named `bio`.

In fact, there are only two things worth mentioning:

1. Documentation. Each function in the module file is documented using the
   [roxygen2](http://cran.r-project.org/web/packages/roxygen2/index.html)
   syntax. It works the same as for packages. The *modules* package parses the
   documentation and makes it available via `module_help` and `?`.

2. The module exports [S3 functions](http://adv-r.had.co.nz/S3.html). The
   *modules* package takes care to register such functions automatically but
   this only works for *user generics* that are defined inside the same module.
   When overriding “known generics” (such as `print`), we need to register
   these manually via `register_S3_method` (this is necessary since these
   functions are inherently ambiguous and there is no automatic way of finding
   them).

## Nested modules

Modules can also be nested in hierarchies. In fact, here is the implementation
of `bio` (in [`bio/__init__.r`](bio/__init__.r): since `bio` is a
directory rather than a file, the module implementation resides in the nested
file `__init__.r`):

```{r file='bio/__init__.r'}
```

The submodule is specified as `'./seq'` rather than `'seq'`: the
explicitly provided relative path prevents lookup in the import search path
(that we set via `options(import.path=…)` earlier); instead, only the current
directory is considered.

We can now use the `bio` module:

```{r}
mod::set_options(path = NULL) # Reset search path
mod::use(./bio)
ls(bio)
ls(bio$seq)
bio$seq$revcomp('CAT')
```

We could also have implemented `bio` as follows:

```{r eval=FALSE}
#' @export
mod::use(./seq[...])
```

This would have made all of `seq`’s definitions immediately available in
`bio`. This is sometimes useful, but should be employed with care.


Module files can contain arbitrary code. It is executed when loaded for the
first time: subsequent `import`s in the same session, regardless of whether they
occur in a different scope, will refer to the loaded, cached module, and will
*not* reload a module.

We can illustrate this by loading a module which has side-effects, `'info'`.

```{r file='info.r'}
```

Let’s load it:

```{r}
mod::use(./info)
```

We have imported the module, and get the diagnostic messages. Let’s re-import
the module:

```{r}
mod::use(./info)
```

… no messages are displayed. However, we can explicitly *reload* a module. This
clears the cache, and loads the module again:

```{r}
# mod::reload(info)
```

And this displays the messages again. The `reload` function is a shortcut for
`unload` followed by `import` (using the exact same arguments as used on the
original `import` call).

The `info` module also show-cases two important helper functions:

1. `module_name` contains the name of the module with which it was loaded. This
   is especially handy because outside of a module `module_name` is `NULL`. We
   can harness this in a similar way to Python’s `__name__` mechanism.

2. `module_file` works equivalently to `system.file`: it returns the full path
   to any file within a module. This is helpful when distributing data files
   with modules, which are loaded from within the module. When invoked without
   arguments, `module_file` returns the full path to the directory containing
   the module source file.
