---
title: "Migration guide"
author: Konrad Rudolph
date: "`r Sys.Date()`"
output:
    rmarkdown::html_document:
        theme: "cerulean"
        toc: true
        toc_float:
            collapsed: false
        number_sections: true
        highlight: "tango"
    md_document:
        variant: gfm
vignette: >
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteIndexEntry{Migration guide}
    %\VignetteEncoding{UTF-8}
---

## ‘modules’ “v1.0” == ‘pod’

‘pod’ is the spiritual successor of the [‘modules’ package][modules], which will
forever remain at version 0.9.*x*. However, the API of ‘pod’ intentionally
breaks backwards compatibility, and module code written for use with ‘modules’
will no longer work with ‘pod’.

The following guide is intended to ease migration to ‘pod’. **Migration is
strongly recommended**, since the authors believe that ‘modules’ had conceptual
shortcomings that have been fixed in ‘pod’, and to keep the ecosystem
consolidated. For the time being, ‘modules’ will receive support (only) in the
form of critical bug fixes.

## Importing modules and packages

### General syntax

With the ‘modules’ package, modules and packages were imported via

```{r eval = FALSE}
library(modules)

# …

modname = import('prefix/modname')
pkgname = import_package('pkgname')
```

With ‘pod’, modules and packages are imported via [`pod::use()`][pod::use]:

```{r eval = FALSE}
pod::use(prefix/modname)
pod::use(pkgname)
```

Notably, module and package names in a use declaration in ‘pod’ are unquoted,
unevaluated expressions; and **the ‘pod’ package is never loaded via
`library()`**. In fact, `library(pod)` raises an error.

Furthermore, with ‘pod’, module names *must* be fully qualified. The equivalent
of the ‘modules’ code `mod = import('modname')` no longer exists. To import a
*local* module without namespace prefix, instead use

```{r eval = FALSE}
pod::use(./modname)
```

`pod::use()` has no return value. Instead, it automatically creates an alias with
the module/package name in the calling scope *if no names are attached* (see
below). To override the alias name, specify it as as a named argument:

```{r eval = FALSE}
pod::use(mod_alias = prefix/modname)
```

Unlike with `modules::import()`, `pod::use()` allows (and encourages) multiple
use declarations at once:

```{r eval = FALSE}
pod::use(
    prefix/mod1,
    mod = prefix/mod2,
    pkg
)
```

### Attaching names

In ‘modules’, the `attach` and `attach_operators` parameters controlled if and
which names were attached. In ‘pod’, attachment is controlled via attach list
declarations:

```{r eval = FALSE}
# ‘modules’:
import('prefix/mod', attach = c('name1', 'name2'))

# ‘pod’:
pod::use(prefix/mod[name1, name2])
```

Wildcard attach lists are also supported:

```{r eval = FALSE}
# ‘modules’:
import('prefix/mod', attach = TRUE)

# ‘pod’:
pod::use(prefix/mod[...])
```

To introduce a module/package alias when attaching names, specify an alias name:

```{r eval = FALSE}
# ‘modules’:
mod = import('prefix/mod', attach = c('name1', 'name2'))

# ‘pod’:
pod::use(mod = prefix/mod[name1, name2])
```

‘pod’ also allows declaring aliases for attached names; this feature did not
exist in ‘modules’:

```{r eval = FALSE}
# Declare alias for one name, attach other name unchanged:
pod::use(prefix/mod[name_alias = name1, name2])

# Declare alias for two names, attach all other exported names unchanged:
pod::use(prefix/mod[name_alias1 = name1, name_alias2 = name2, ...])
```

The `attach_operators` option from ‘modules’ has been dropped. If users require
operators, they need to explicitly attach them when using ‘pod’.

### Loading documentation

The `doc` option from `modules::import()` has been dropped without replacement.
‘pod’ loads documentation lazily only when it is requested via `pod::help()`
(see below).

## Executing code during module loading

The ‘modules’ package treated modules as regular R source code files: upon
importing them, the entire code inside a module file was executed. ‘pod’
conceptually no longer does this. It regards module source code as
*declarative*: the module source code defines a number of names to be exported.
However, code with side-effects on the module file level is no longer guaranteed
to execute.

Instead, ‘pod’ introduces [module event hooks][hooks], in particular
`.on_load()`, which is a function that gets executed whenever a module is first
loaded inside an R session.

## Changed options

In ‘modules’, the module search path was set via `options('import.path')`. In
‘pod’, use `options('pod.path')` instead.

The ‘modules’ options `options('import.attach')` and `options('warn.conflicts')`
no longer exist. In particular, ‘pod’ no longer warns of name conflicts when
attaching names. Instead, it encourages consciously choosing which names to
attach.

## Changed function names

The ‘modules’ function `module_file` is now called [`pod::file()`][pod::file].
Its semantics have also changed: it no longer cares whether files relative to
the module exist or not; it merely constructs appropriate path strings.

The ‘module’ function `module_name` is now called [`pod::name()`][pod::name]. It
no longer has any arguments.

## Exporting names from modules

With the ‘modules’ packages, module source files exported all non-hidden names;
that is, all names that didn’t start with a dot (`.`).

‘pod’ makes exporting explicit. By default, *no* names are exported from a
module, unless they are marked with the directive comment `#' @export`:

```{r eval = FALSE}
# This function is not exported:
f1 = function () {}

# This nested module is not exported
pod::use(./nested1)

# This function is exported:
#' @export
f2 = function () {}

# This nested module is exported
#' @export
pod::use(./nested2)
```

`@export` directives that decorate `pod::use()` declarations apply to *all*
names declared in it:

```{r eval = FALSE}
#' @export
pod::use(
    pkg_alias = pkg,
    prefix/mod,
    prefix/mod2[a, b, c]
)
```

The above code will export the names `pkg_alias`, `mod`, `a`, `b` and `c`.

## Loading parents of nested modules

Consider the following file hierarchy defining a nested module:

<pre><code><b>a</b>
├─ <i>__init__.r</i>
╰─ <b>b</b>
   ├─ <i>__init__.r</i>
   ╰─ <i><b>c</b>.r</i></code></pre>

In ‘modules’, the declaration `import(a/b/c)` would import the module `c`, but
this would first execute the code of the modules `a` and `a/b`. In other words
it would source the files `a/__init__.r`, `a/b/__init__.r`, and `a/b/c.r`, in
this order.

‘pod’ no longer loads the full module hierarchy: `pod::use(a/b/c)` loads only
the module defined by `a/b/c.r`. Likewise, `pod::use(a/b)` does *not*
automatically load `a/b/c.r` (but the same behaviour was already present in
‘modules’).

## Displaying documentation

‘modules’ overrode the `help` function and the `?` operator to allow displaying
module documentation. Since ‘pod’ is no longer attached, these functions no
longer display module documentation. Instead, the documentation of anything
imported via ‘pod’ (both modules and packages!) can be queried via
[`pod::help()`][pod::help].

Unlike ‘modules’, ‘pod’ also supports displaying the documentation of nested
module names, e.g. `pod::help(a$b$c)`.

## Cyclic imports

Cyclic/circular imports are supported by both ‘modules’ and ‘pod’. However, the
level of support differs. The details are complicated, and it is generally
recommended to avoid cyclic modules. However, there are some situations where
circularity in the dependencies makes sense, and ‘pod’ strives to make this
work, where technically possible.

For instance, consider the following (nonsensical) working, circular definition
of the functions `even` and `odd`, which determine whether a non-negative
integer is even or odd:

* `even.r`:

    ```{r eval = FALSE}
    pod::use(./odd[...])

    #' @export
    even = function (n) {
        n == 0L || ! odd(n)
    }
    ```

* `odd.r`:

    ```{r eval = FALSE}
    pod::use(./even[...])

    #' @export
    odd = function (n) {
        n != 0L && even(n - 1L)
    }
    ```

These modules compute `even` in terms of `odd`, and vice-versa. Yet ‘pod’ has no
trouble importing and using both these modules. However, this no longer works
once we attempt to export imported submodules themselves. That is, the following
version of `odd.r` would cause an error:

* `odd.r`:

    ```{r eval = FALSE}
    #' @export
    pod::use(./even[...])

    #' @export
    odd = function (n) {
        n != 0L && even(n - 1L)
    }
    ```

[modules]: https://github.com/klmr/modules
[pod::use]: https://klmr.me/pod/reference/use.html
[hooks]: https://klmr.me/pod/reference/mod-hooks.html
[pod::file]: https://klmr.me/pod/reference/file.html
[pod::name]: https://klmr.me/pod/reference/name.html
[pod::help]: https://klmr.me/pod/reference/help.html
